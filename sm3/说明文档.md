 一、SM3 基本软件实现与效率改进

（一）SM3 算法基本原理

SM3 算法的处理过程主要包括消息填充、消息分组、压缩函数迭代等步骤。



1.  消息填充：对于任意长度的消息 $M$，首先将其转换为二进制位串，然后计算填充的位数。填充规则为：先在消息末尾添加一个 “1”，再添加 $k$ 个 “0”（$k$ 是满足（消息长度 + 1 + $k$）≡ 448 mod 512 的最小非负整数），最后添加一个 64 位二进制数（表示消息原始长度，以位为单位）。

2.  消息分组：经过填充后的消息被分成若干个 512 位的消息块，记为$M_0, M_1, ..., M_{n-1}$，其中 $n$ 为分组数量。

3.  压缩函数迭代：SM3 算法的压缩函数以一个 256 位的初始值 $IV$ 和一个 512 位的消息块$M_i$作为输入，输出一个 256 位的哈希值。初始值 $IV$ 是固定的，其值为：0x7380166f, 0x4914b2b9, 0x172442d7, 0xda8a0600, 0xa96f30bc, 0x163138aa, 0xe38dee4d, 0xb0fb0e4e。

压缩函数的具体运算过程如下：



*   将消息块$M_i$分解为 16 个 32 位的字$W_0, W_1, ..., W_{15}$。

*   扩展生成 68 个 32 位的字$W_0, W_1, ..., W_{67}$和 64 个 32 位的字$W'_0, W'_1, ..., W'_{63}$，扩展规则为：


    *   对于 $j = 16$ 到 $67$：$W_j = P_1(W_{j-16} \oplus W_{j-9} \oplus (W_{j-3} \ll 15)) \oplus (W_{j-13} \ll 7) \oplus W_{j-6}$；

    *   对于 $j = 0$ 到 $63$：$W'_j = W_j \oplus W_{j+4}$。

        其中$P_1(X) = X \oplus (X \ll 15) \oplus (X \ll 23)$，$\ll$表示循环左移操作。

*   初始化 8 个 32 位的寄存器 $A, B, C, D, E, F, G, H$，初始值为当前哈希值（初始时为 $IV$）。

*   进行 64 轮迭代运算，对于每一轮 $j$（0 到 63）：


    *   $SS1 = ((A \ll 12) + E + (T_j \ll j)) \ll 7$；

    *   $SS2 = SS1 \oplus (A \ll 12)$；

    *   $TT1 = FF_j(A,B,C) + D + SS2 + W'_j$；

    *   $TT2 = GG_j(E,F,G) + H + SS1 + W_j$；

    *   更新寄存器：$D = C$；$C = B \ll 9$；$B = A$；$A = TT1$；$H = G$；$G = F \ll 19$；$F = E$；$E = P_0(TT2)$。

        其中$T_j$是常量（$0 \leq j \leq 15$时，$T_j = 0x79cc4519$；$16 \leq j \leq 63$时，$T_j = 0x7a879d8a$）；$FF_j$和$GG_j$是布尔函数（$0 \leq j \leq 15$时，$FF_j(X,Y,Z) = X \oplus Y \oplus Z$，$GG_j(X,Y,Z) = X \oplus Y \oplus Z$；$16 \leq j \leq 63$时，$FF_j(X,Y,Z) = (X \land Y) \lor (X \land Z) \lor (Y \land Z)$，$GG_j(X,Y,Z) = (X \land Y) \lor (\lnot X \land Z)$）；$P_0(X) = X \oplus (X \ll 9) \oplus (X \ll 17)$。

*   迭代结束后，将寄存器值与初始寄存器值进行异或运算，得到新的哈希值，作为下一个消息块处理的输入。

当所有消息块处理完毕后，最终得到的哈希值即为 SM3 算法对消息 $M$ 的哈希结果。

（二）基本软件实现思路



1.  数据类型定义：使用 32 位无符号整数（$uint32_t$）表示算法中涉及的字，使用字节数组（$uint8_t$）存储消息和哈希结果。

2.  消息填充实现：通过函数实现消息填充功能，计算原始消息长度（以位为单位）和需要填充的 “0” 的位数，在消息末尾依次添加 “1”、相应数量的 “0” 和消息长度的 64 位表示。

3.  消息扩展实现：通过函数生成 $W$ 和 $W'$ 数组，先初始化 $W[0..15]$，再根据扩展规则计算 $W[16..67]$ 和 $W'[0..63]$。

4.  压缩函数实现：通过函数处理单个 512 位块，生成 $W$ 和 $W'$ 数组，初始化工作寄存器，进行 64 轮迭代运算，迭代结束后将寄存器值与初始向量异或。
    
6.  SM3 哈希主函数：初始化初始向量，对消息进行填充，按块处理填充后的消息，将每个块转换为 16 个 32 位大端整数后调用压缩函数，最后将结果转换为字节数组（大端）作为哈希值。

（三）执行效率改进



1.  循环展开：在 64 轮迭代运算中，将循环适当展开（如每 8 轮作为一个块），减少循环控制语句的执行次数，提高 CPU 执行效率。

2.  常量预计算：通过宏定义轮常量，在编译时确定常量值，避免迭代过程中重复计算，节省时间。

3.  位运算优化:通过宏定义实现循环左移操作，合理利用 CPU 支持的位运算指令，提高运算速度。

4.  内存访问优化：在消息扩展和迭代过程中，$W$ 和 $W'$ 数组按访问顺序存储，提高数据的缓存命中率，减少缓存未命中情况。

 三、基于 SM3 的长度扩展攻击验证

（一）长度扩展攻击原理

长度扩展攻击是指对于某些哈希函数，攻击者在已知消息 $M$ 的哈希值 $H(M)$ 和消息长度 $len(M)$ 时，无需知道 $M$ 的具体内容，即可计算出消息 $M || padding(M) || M'$ 的哈希值 $H(M || padding(M) || M')$（其中 $padding(M)$ 是 $M$ 的填充部分，$M'$ 是攻击者选择的任意消息）。

SM3 算法的压缩函数具有迭代性质，哈希结果通过对消息块连续压缩得到。攻击者可利用这一性质，将已知哈希值作为新的初始值，对 $M'$ 进行压缩运算，得到扩展消息的哈希值。

（二）验证过程



1.  准备工作：选择消息 $M$，计算其哈希值 $H$ 和消息长度 $len(M)$。

2.  计算填充部分：根据 SM3 填充规则，计算 $padding(M)$。

3.  构造扩展消息：扩展消息为 $M || padding(M) || M'$（$M'$ 为任意消息）。

4.  模拟哈希计算：将已知哈希值 $H$ 作为初始值，对 $M'$ 进行 SM3 哈希计算（考虑 $M || padding(M)$ 的长度对填充的影响），得到哈希值 $H'$。

5.  实际计算验证：直接计算扩展消息的 SM3 哈希值 $H''$，比较 $H'$ 和 $H''$ 是否相等，若相等则验证 SM3 算法存在长度扩展攻击的可能性。

（三）数学推导与表示

设 $H(M)$ 是消息 $M$ 的 SM3 哈希值，$len(M)$ 为 $M$ 的长度（以位为单位），$padding(M)$ 是 $M$ 的填充部分，满足 $len(M) + len(padding(M)) = 512k$（$k$ 为整数）。

对于扩展消息 $M'$（长度为 $len(M')$），扩展消息 $M || padding(M) || M'$ 的长度为 $512k + len(M')$。

SM3 算法计算哈希值的过程可表示为：$H(M) = Compress(IV, M_0, M_1, ..., M_{n-1})$（$Compress$ 是压缩函数，$M_0, ..., M_{n-1}$ 是 $M$ 填充后的消息块）。

扩展消息的哈希值为$H(M||padding(M)||M') = Compress(H(M), M'_0, M'_1, ..., M'_{m-1})$（$M'_0, ..., M'_{m-1}$ 是 $M'$ 填充后的消息块，考虑 $M || padding(M)$ 的长度）。

由此可知，已知 $H(M)$ 和 $len(M)$ 时，可计算出$H(M||padding(M)||M')$，从而验证长度扩展攻击。

四、基于 SM3 构建 Merkle 树及相关证明

（一）Merkle 树原理（RFC6962)

Merkle 树是一种哈希树，由叶子节点、非叶子节点和根节点组成。叶子节点是数据块的哈希值，非叶子节点是其两个子节点哈希值串联后的哈希值，根节点是树的顶部节点，代表所有数据块的哈希值。

根据 RFC6962，构建规则如下：



1.  叶子节点：对于每个数据块 $d_i$，计算其哈希值 $h_i = SM3(d_i)$。

2.  非叶子节点：若节点有两个子节点 $l$ 和 $r$，则其哈希值为 $h = SM3(0x01 || l || r)$（$0x01$ 为标记位，区分内部节点和叶子节点的哈希计算）。

3.  根节点：当叶子节点数量为奇数时，最后一个叶子节点复制一份作为兄弟节点，再按非叶子节点计算规则向上构建，直到得到根节点。

（二）构建 10w 叶子节点的 Merkle 树



1.  准备叶子节点：获取 10w 个数据块，分别计算其 SM3 哈希值，得到 10w 个叶子节点$h_0, h_1, ..., h_{99999}$。

2.  处理叶子节点数量：10w 是偶数，无需复制叶子节点。将叶子节点两两分组，计算每组父节点哈希值（如$h_0$和$h_1$的父节点哈希值为$h_{0-1} = SM3(0x01||h_0||h_1)$），得到 5w 个非叶子节点。

3.  迭代构建上层节点：将非叶子节点再次两两分组，按同样规则计算父节点哈希值（数量为奇数时，最后一个节点复制一份），重复此过程直到得到根节点。

（三）叶子的存在性证明

存在性证明用于证明某个叶子节点在 Merkle 树中，过程如下：



1.  找到要证明存在的叶子节点$h_i$在树中的位置。

2.  获取该叶子节点的兄弟节点哈希值。

3.  计算这两个节点的父节点哈希值，再找到该父节点的兄弟节点哈希值。

4.  重复上述过程，直到计算到根节点。

5.  比较获取的兄弟节点哈希值序列和计算得到的根节点与 Merkle 树的根节点，若一致则证明该叶子节点存在。

例如，证明叶子节点$h_5$存在：



   $h_5$的兄弟节点是$h_4$，计算父节点$h_{4-5} = SM3(0x01||h_4||h_5)$。
   
   $h_{4-5}$的兄弟节点假设为$h_{6-7}$，计算父节点$h_{4-7} = SM3(0x01||h_{4-5}||h_{6-7})$。

   以此类推，直到计算出根节点 $root$，若 $root$ 与树的根节点相同，则证明$h_5$存在。

（四）叶子的不存在性证明

不存在性证明用于证明某个数据块对应的叶子节点不在 Merkle 树中，过程如下：



1.  确定要证明不存在的数据块 $d$，计算其哈希值 $h = SM3(d)$。

2.  在叶子节点中查找 $h$，未找到则进行下一步。

3.  找到与 $h$ 相邻的两个叶子节点$h_{left}$和$h_{right}$（假设$h_{left} < h < h_{right}$，叶子节点按某种顺序排序）。

4.  分别对$h_{left}$和$h_{right}$进行存在性证明。

5.  由于 $h$ 不在$h_{left}$和$h_{right}$之间，且$h_{left}$和$h_{right}$存在于树中，因此证明 $h$ 不存在于 Merkle 树中。

> （注：文档部分内容可能由 AI 生成）
