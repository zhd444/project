
 一、协议原理与数学推导

 1.1 协议目标



*   参与方：用户端（P1）和服务器端（P2）

*   P1 输入：用户密码集合 $  V = \{v_1, v_2, \ldots, v_n\}  $（实际为密码哈希值）

*   P2 输入：泄露密码库 $  W = \{(w_1, t_1), (w_2, t_2), \ldots, (w_m, t_m)\}  $，其中 $  t_j  $ 为密码风险值

*   目标：计算 $  V \cap W  $ 的大小（泄露密码数量）和风险值总和 $  \sum_{w_j \in V \cap W} t_j  $，且双方均不泄露原始数据

 1.2 核心密码学原语



1.  椭圆曲线群

    基于离散对数假设（DDH）的椭圆曲线群 $  G  $，满足：

*   群中元素为曲线上的点，运算为点加和标量乘法

*   生成元 $  g \in G  $，阶为 $  q  $（大素数）

*   对于随机数 $  a, b \in \mathbb{Z}_q^*  $，无法区分 $  g^{ab}  $ 与随机群元素（DDH 假设）

1.  哈希函数

    抗碰撞哈希函数 $  H: \{0,1\}^* \to G  $，将任意输入映射到椭圆曲线群中的点。

2.  加法同态加密
   
    采用 Paillier 加密方案，满足：

*   密文加法：$  \text{Enc}(t_1) + \text{Enc}(t_2) = \text{Enc}(t_1 + t_2)  $

*   仅持有私钥可解密，确保风险值求和过程的隐私性

1.3 协议流程

步骤 1：初始化



*   P1 和 P2 约定椭圆曲线群 $  G  $（如 NIST256p）、哈希函数 $  H  $

*   P1 生成私钥 $  k_1 \in \mathbb{Z}_q^*  $

*   P2 生成私钥 $  k_2 \in \mathbb{Z}_q^*  $ 和 Paillier 密钥对 $  (pk, sk)  $，并将 $  pk  $ 发送给 P1

步骤 2：第一轮交互（P1 → P2）

P1 对每个 $  v_i \in V  $ 执行：



1.  计算哈希点：$  h_i = H(v_i) \in G  $

2.  用私钥加密：$  u_i = h_i^{k_1} \in G  $（椭圆曲线点乘 $  h_i \times k_1  $）

3.  将 $  \{u_1, u_2, \ldots, u_n\}  $ 打乱顺序后发送给 P2

步骤 3：第二轮交互（P2 → P1）

P2 接收 P1 的消息后，执行：



1.  对每个 $  u_i  $ 用私钥加密：$  z_i = u_i^{k_2} = h_i^{k_1 k_2} \in G  $，打乱后发送给 P1（记为集合 $  Z  $）

2.  对每个 $  (w_j, t_j) \in W  $ 执行：

*   计算哈希点：$  h'_j = H(w_j) \in G  $

*   用私钥加密：$  v_j = h'_j^{k_2} \in G  $

*   同态加密风险值：$  c_j = \text{Enc}_{pk}(t_j)  $

1.  将 $  \{(v_j, c_j)\}  $ 打乱顺序后发送给 P1

步骤 4：第三轮交互（P1 → P2）

P1 接收 P2 的消息后，执行：



1.  对每个 $  v_j  $ 用私钥加密：$  z'_j = v_j^{k_1} = h'_j^{k_1 k_2} \in G  $

2.  计算交集：若 $  z'_j \in Z  $，则 $  w_j \in V \cap W  $，收集对应的 $  c_j  $

3.  同态求和：$  C = \sum c_j  $（利用 Paillier 加法同态性），发送 $  C  $ 给 P2

步骤 5：结果计算

P2 用私钥解密：$  \sum t_j = \text{Dec}_{sk}(C)  $，交集大小为收集的 $  c_j  $ 数量。

1.4 安全性分析



*   隐私性：基于 DDH 假设，双方无法从加密数据中推导出原始输入（如 P2 无法从 $  u_i  $ 反推 $  v_i  $）

*   正确性：仅当 $  w_j = v_i  $ 时，$  h'_j = h_i  $，故 $  z'_j = z_i  $，确保交集计算准确

*   抗攻击性：哈希函数的抗碰撞性和椭圆曲线的离散对数难题防止伪造数据攻击

二、实现思路与技术细节

2.1 关键模块实现

1. 椭圆曲线与哈希映射



```
curve = NIST256p  # 对应secp256r1，满足DDH假设
order = curve.order  # 曲线阶数
generator = curve.generator  # 生成元


def hash_to_curve(data):
    # 哈希数据到整数
    sha256 = hashlib.sha256(data).digest()
    scalar = int.from_bytes(sha256, 'big') % order

    # 映射到曲线上的点（ generator * scalar ）
    return generator * scalar
```



*   哈希映射严格遵循 “哈希→整数→曲线点” 流程，确保结果在椭圆曲线群内

2. 密钥生成



```
k1 = random.randint(1, order - 1)  # P1的私钥
k2 = random.randint(1, order - 1)  # P2的私钥


# 3. 生成Paillier同态加密密钥
paillier_pub, paillier_priv = paillier.generate_paillier_keypair()
```


3. 协议交互实现



*   第一轮交互：P1 生成加密后的用户数据



```
p1_step1 = []
for v in V:
    h = hash_to_curve(v)  # H(v_i)
    encrypted_v = h * k1  # H(v_i)^k1
    p1_step1.append(encrypted_v)
random.shuffle(p1_step1)  # 打乱顺序
```



*   第二轮交互：P2 处理并返回双重加密数据



```
# 步骤2.1: 处理P1的消息
p2_step2_z = [z * k2 for z in p1_step1]  # H(v_i)^(k1*k2)
random.shuffle(p2_step2_z)
# 转为元组集合便于比较（点的坐标）
Z_set = set((p.x(), p.y()) for p in p2_step2_z)

# 步骤2.2: 处理P2自己的W
p2_step2_w = []
for w, t in W:
    h_w = hash_to_curve(w)  # H(w_j)
    encrypted_w = h_w * k2  # H(w_j)^k2
    encrypted_t = paillier_pub.encrypt(t)  # 加密风险值
    p2_step2_w.append((encrypted_w, encrypted_t))
random.shuffle(p2_step2_w)  # 打乱顺序
```



*   第三轮交互：P1 计算交集并求和



```
intersection_ciphertexts = []
for enc_w, enc_t in p2_step2_w:
    # 计算 H(w_j)^(k1*k2)
    encrypted_w_k1k2 = enc_w * k1
    # 检查是否在交集中
    if (encrypted_w_k1k2.x(), encrypted_w_k1k2.y()) in Z_set:
        intersection_ciphertexts.append(enc_t)

# 同态求和
sum_cipher = sum(intersection_ciphertexts) if intersection_ciphertexts else paillier_pub.encrypt(0)

```

 2.2 数据处理优化



*   乱序处理：每轮交互均对数据打乱顺序，防止攻击者通过位置关联推测原始数据

*   点比较：通过椭圆曲线点的坐标（x, y）判断相等性，确保交集计算准确

*   异常处理：对哈希映射和点运算增加校验，避免无效数据进入流程
